/*
 * IMPORTANT Commenting note: MPNEClient is largely contained in one method,
 * so its comments are thorough as to promote readability. See the table of
 * contents below and the section headers (block comments starting with "~")
 */
/*-
 * Table of contents: (order of sections)
 * 
 * public class MPNEClient
 * 	~Protocol flags
 * 	~Working variables
 * 
 * 	public static void main
 * 		~Initialization
 * 		~Running loop
 * 			~If user inputs a command
 * 				~Command: help
 * 				~Command: exit
 * 				~Command: info
 * 				~Command: connect
 * 				~Command: list
 * 				~Command: disconnect
 * 				~Command: name
 * 				~Unknown command
 * 			~If user inputs a message
 * 		~Finalization
 */

package com.gmail.cmorley191.mpnechat;

import java.io.IOException;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;

import com.gmail.cmorley191.mpne.ConnectionListener;
import com.gmail.cmorley191.mpne.MPNESocket;
import com.gmail.cmorley191.mpne.MPNESocket.SocketPeerConnection;

/**
 * Demonstration of MPNE UDP framework ({@link MPNESocket} and
 * {@link MPNESocket.SocketPeerConnection}) in the form of a console
 * peer-to-peer chat application.
 * 
 * @author Charlie Morley
 *
 */
public class MPNEClient {

	/*
	 * ~Protocol flags (sequences of bytes used to structure the data packets,
	 * abbreviated PF)
	 */
	/*
	 * Protocol flag terminology: "Level" indicates in which section flags
	 * appear - "L1L2L3L4L5L6..." (a flag in L2 comes directly after L1 with no
	 * bytes in between, for example). "final" indicates this is the last flag
	 * used in a packet (though other information may follow the final flag if
	 * the flag requires it, e.g. MESSAGE_TEXT requires the message in plain
	 * text).
	 */

	/*-
	 * How to read or use the protocol flag commenting scheme:
	 * Each flag lists its level, purpose, and protocol. (lack of a protocol means just use the flag alone)
	 * Flags on the same level and following the same flag tree should never have identical data, but differing levels and trees may.
	 * Start by adding the L1 flag.
	 * Then find the L2 flag applicable to the situation.
	 * Continue adding flags until a final flag is added.
	 * 
	 * Example: 
	 * Structuring a technical message letting users know this client's new name is "John":
	 * L1: PF_MEDIUMCHAT (because it is mandatory for all packets)
	 * L2: PF_UPDATE (because it is for technical update packets)
	 * L3, final: PF_VARIABLE_PROFILE (because it is for an update or enquiry relating to usernames)
	 * 
	 * The packet would look like:
	 * [PF_MEDIUMCHAT][PF_UPDATE][PF_VARIABLE_PROFILE]["John"]
	 * The "John" information is due to the individual flag protocol for PF_VARIABLE_PROFILE.
	 * 
	 * Note that the variables are listed in order of relevance, not necessarily by level.
	 */

	/**
	 * (L1) for all packets in Medium Chat.
	 * <p>
	 * Indicates this packet was generated by a Medium Chat client. Any packets
	 * that do not start with this flag are ignored.
	 */
	static final byte[] PF_MEDIUMCHAT = new byte[] { 1, 77, 25 };

	/**
	 * (L2, final, after {@link #PF_MEDIUMCHAT MEDIUMCHAT}) for messages from
	 * peer users.
	 * <p>
	 * Indicates this packet contains a new message from the peer user and
	 * indicates the start of the message content directly following.<br>
	 * Protocol: [flag][remaining bytes: message in plain text] (end of packet)
	 */
	static final byte[] PF_MESSAGE = new byte[] { 2 };

	/**
	 * (L2, after {@link #PF_MEDIUMCHAT MEDIUMCHAT}) for technical notifications
	 * from peer clients.
	 * <p>
	 * Indicates that this packet contains a technical update about the peer
	 * user, not a chat message from the user or a request for information.
	 */
	static final byte[] PF_UPDATE = new byte[] { 7 };
	/**
	 * (L3, final, after {@link #PF_UPDATE UPDATE}) for notifications that the
	 * peer has opened a channel to the receiving peer.
	 * <p>
	 * Indicates that the receiving peer may receive more packets from the peer
	 * until it disconnects.
	 */
	static final byte[] PF_UPDATE_CONNECT = new byte[] { 22 };
	/**
	 * (L3, final, after {@link #PF_UPDATE UPDATE}) for notifications that the
	 * peer is closing the channel to the receiving peer.
	 * <p>
	 * Indicates that the receiving peer won't receive more packets from the
	 * peer until it reconnects.
	 */
	static final byte[] PF_UPDATE_DISCONNECT = new byte[] { 25 };

	/**
	 * (L2, after {@link #PF_MEDIUMCHAT MEDIUMCHAT}) for technical requests to
	 * receive information from peer clients.
	 * <p>
	 * Indicates that this packet contains a technical request for information
	 * about the receiving peer user or client, not a message from or
	 * notification about the peer user.
	 */
	static final byte[] PF_ENQUIRY = new byte[] { 5 };

	/**
	 * Flag used in a variety of situations - always relating to the username of
	 * the peer user.
	 * <p>
	 * (L3, final, after {@link #PF_UPDATE UPDATE}) for notifications that the
	 * peer has changed username.<br>
	 * Indicates that the peer has changed username and indicates the start of
	 * the peer's new username directly following.<br>
	 * Protocol: [flag][remaining bytes: new username in plain text] (end of
	 * packet)
	 * <p>
	 * (L3, final, after {@link #PF_ENQUIRY ENQUIRY}) for requests for the
	 * receiving peer's current username.<br>
	 * Indicates a request for the receiving peer to send back an update of its
	 * current username.
	 */
	static final byte[] PF_VARIABLE_PROFILE = new byte[] { 17 };

	/*
	 * ~Functional variables
	 */
	/**
	 * This client's username data.
	 */
	private static byte[] currentProfile = null;

	public static void main(String[] args) {
		/*
		 * ~Initialization
		 */
		Scanner scanner = new Scanner(System.in);

		MPNESocket socket;
		while (true) {
			System.out.print("Enter local port: ");
			try {
				socket = new MPNESocket(Integer.parseInt(scanner.nextLine().trim()));
				break;
			} catch (Exception e) {
				System.out.println("Invalid port");
			}
		}
		System.out.println("Opened socket.");

		ArrayList<SocketPeerConnection> peers = new ArrayList<SocketPeerConnection>();
		ArrayList<ConnectionListener> peerListeners = new ArrayList<ConnectionListener>();
		System.out.println("Enter to send data to connected peers. Use \"/help\" for a list of commands.");

		/*
		 * ~Running loop
		 */
		while (true) {
			String line = scanner.nextLine();

			/*
			 * ~If user inputs a command
			 */
			if (line.startsWith("/")) {
				line = line.substring(1);

				/*
				 * ~Command: help
				 */
				if (line.startsWith("help")) {
					System.out.println("/help - Shows this list");
					System.out.println("/exit - Closes the socket and exits");
					System.out.println("/info - Shows information about this client and session");
					System.out.println("/connect [host] [port] - Opens two-way channel to this peer");
					System.out.println("/list - Lists all open peer channels");
					System.out.println("/disconnect [host] - Closes all channels to the specified host");
					System.out.println("/name [username] - Sets this client's display name");

					/*
					 * ~Command: exit
					 */
				} else if (line.startsWith("exit"))
					break;

				/*
				 * ~Command: info
				 */
				else if (line.startsWith("info")) {
					try {
						System.out.println("Local host IP: " + InetAddress.getLocalHost().getHostAddress());
					} catch (UnknownHostException e) {
					}
					System.out.println("Local host port: " + socket.getPort());
					System.out.println(((currentProfile == null)
							? "No username set - others are shown this machine's IP and port as the username"
							: "Current username: " + new String(currentProfile)));
				}

				/*
				 * ~Command: connect
				 */
				else if (line.startsWith("connect")) {
					line = line.substring(7);
					String[] parts = line.split(" ");
					if (parts.length != 3)
						System.out.println("Bad syntax");
					else {
						try {
							SocketPeerConnection connection = socket.new SocketPeerConnection(
									InetAddress.getByName(parts[1]), Integer.parseInt(parts[2]));
							String host = connection.getAddress().toString() + ":" + connection.getPort();
							if (peers.contains(connection)) {
								System.out.println("Channel already open to " + host);
							} else {
								ConnectionListener listener = new ConnectionListener() {

									/**
									 * {@code true} if the peer most recently
									 * sent a connection notification,
									 * {@code false} otherwise.
									 */
									private boolean connected = false;

									/**
									 * The peer's display name. Equal to the
									 * username, if available, otherwise equal
									 * to the IP address and port (host).
									 */
									private String name = host;

									@Override
									public void dataReceived(byte[] data) {
										int pos = 0;
										if (!startsWith(data, PF_MEDIUMCHAT, pos))
											return;
										pos += PF_MEDIUMCHAT.length;
										if (startsWith(data, PF_MESSAGE, pos)) {
											pos += PF_MESSAGE.length;
											System.out.println("<" + name + "> "
													+ new String(Arrays.copyOfRange(data, pos, data.length)));
										} else if (startsWith(data, PF_UPDATE, pos)) {
											pos += PF_UPDATE.length;
											if (startsWith(data, PF_UPDATE_CONNECT, pos)) {
												if (!connected) {
													System.out.println(name + " has connected.");
													connected = true;
													try {
														connection.send(
																concat(PF_MEDIUMCHAT, PF_UPDATE, PF_UPDATE_CONNECT));
													} catch (IOException e) {
													}
													try {
														connection.send(
																concat(PF_MEDIUMCHAT, PF_ENQUIRY, PF_VARIABLE_PROFILE));
													} catch (IOException e) {
													}
												}
											} else if (startsWith(data, PF_UPDATE_DISCONNECT, pos)) {
												System.out.println(name + " has disconnected.");
												connected = false;
											} else if (startsWith(data, PF_VARIABLE_PROFILE, pos)) {
												pos += PF_VARIABLE_PROFILE.length;
												String newName = new String(Arrays.copyOfRange(data, pos, data.length));
												System.out.println(name + " has changed their username to " + newName);
												name = newName;
											}
										} else if (startsWith(data, PF_ENQUIRY, pos)) {
											pos += PF_ENQUIRY.length;
											if (startsWith(data, PF_VARIABLE_PROFILE, pos))
												if (currentProfile != null)
													try {
														connection.send(concat(PF_MEDIUMCHAT, PF_UPDATE,
																PF_VARIABLE_PROFILE, currentProfile));
													} catch (IOException e) {
													}
										}
									}

									private boolean startsWith(byte[] data, byte[] expr, int startPos) {
										if (expr.length > data.length - startPos)
											return false;
										for (int i = 0; i < expr.length; i++)
											if (data[startPos + i] != expr[i])
												return false;
										return true;
									}
								};
								connection.addConnectionListener(listener);
								peerListeners.add(listener);
								peers.add(connection);
								System.out.println("Channel open to " + host);
								try {
									connection.send(concat(PF_MEDIUMCHAT, PF_UPDATE, PF_UPDATE_CONNECT));
								} catch (IOException e) {
								}
							}
						} catch (UnknownHostException e) {
							System.out.println("Invalid host");
						} catch (NumberFormatException e) {
							System.out.println("Invalid port");
						}
					}

					/*
					 * ~Command: list
					 */
				} else if (line.startsWith("list")) {
					System.out.println(peers.size() + " open channel" + ((peers.size() != 1) ? "s" : "")
							+ ((peers.size() != 0) ? ":" : "."));
					for (SocketPeerConnection peer : peers)
						System.out.println(peer.getAddress().toString() + ":" + peer.getPort());

					/*
					 * ~Command: disconnect
					 */
				} else if (line.startsWith("disconnect")) {
					line = line.substring(10);
					String[] parts = line.split(" ");
					if (parts.length != 2)
						System.out.println("Bad syntax");
					else {
						try {
							InetAddress address = InetAddress.getByName(parts[1]);
							ArrayList<SocketPeerConnection> removeList = new ArrayList<SocketPeerConnection>();
							for (SocketPeerConnection peer : peers)
								if (peer.getAddress().equals(address))
									removeList.add(peer);
							for (SocketPeerConnection peer : removeList) {
								ConnectionListener listener = peerListeners.get(peers.indexOf(peer));
								peer.removeConnectionListener(listener);
								peerListeners.remove(listener);
								peers.remove(peer);
								System.out.println("Closed channel to " + address.toString() + ":" + peer.getPort());
								try {
									peer.send(concat(PF_MEDIUMCHAT, PF_UPDATE, PF_UPDATE_DISCONNECT));
								} catch (IOException e) {
								}
							}
							System.out.println("Closed " + removeList.size() + " channel"
									+ ((removeList.size() != 1) ? "s" : "") + ".");
						} catch (UnknownHostException e) {
							System.out.println("Invalid host");
						}
					}

					/*
					 * ~Command: name
					 */
				} else if (line.startsWith("name")) {
					line = line.substring(4);
					String[] parts = line.split(" ");
					if (parts.length != 2)
						System.out.println("Bad syntax");
					else {
						currentProfile = parts[1].getBytes();
						System.out.println("Username set to " + parts[1]);
						for (SocketPeerConnection peer : peers)
							try {
								peer.send(concat(PF_MEDIUMCHAT, PF_UPDATE, PF_VARIABLE_PROFILE, currentProfile));
							} catch (IOException e) {
							}
					}

					/*
					 * ~Unknown command
					 */
				} else
					System.out.println("Unknown command");

				/*
				 * ~If user inputs a message
				 */
			} else {
				int errors = 0;
				for (SocketPeerConnection peer : peers)
					try {
						peer.send(MPNEClient.concat(PF_MEDIUMCHAT, PF_MESSAGE, line.getBytes()));
					} catch (IOException e1) {
						errors++;
					}
				if (errors != 0)
					System.out.println("Error sending message to " + errors + "peers");
			}
		}

		/*
		 * ~Finalization
		 */

		for (SocketPeerConnection peer : peers)
			try {
				peer.send(concat(PF_MEDIUMCHAT, PF_UPDATE, PF_UPDATE_DISCONNECT));
			} catch (IOException e) {
			}
		socket.close();
		scanner.close();
		System.exit(0);
	}

	/**
	 * Concatenates the specified byte arrays into a single byte array.
	 * 
	 * @param arrays
	 *            the arrays to be concatenated
	 * @return one array containing all the elements in each array specified
	 *         concatenated
	 */
	private static byte[] concat(byte[]... arrays) {
		int len = 0;
		for (byte[] array : arrays)
			len += array.length;
		byte[] full = new byte[len];
		int pos = 0;
		for (byte[] array : arrays) {
			System.arraycopy(array, 0, full, pos, array.length);
			pos += array.length;
		}
		return full;
	}
}
